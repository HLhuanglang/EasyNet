# 计算机网络

参考：

[关于UDP-读这篇就够了（疑难杂症和使用） - 那一抹风情 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yajunLi/p/6605110.html)

[(12条消息) IP数据包长度问题总结_naturebe的博客-CSDN博客_ip数据报的最大长度](https://blog.csdn.net/naturebe/article/details/6712153)

## 基础篇

### **1.OSI七层模型分别是什么？路由器在哪一层？**

![](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/网络分层结构.jpg)

路由器在网络层，交换机在数据链路层(使用MAC)

​	

网络层-传输层都有校验和，来确认包是不是正确的。

### 2.TCP、UDP、IP协议格式

#### IP:



#### TCP:

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20150408112844806" alt="img" style="zoom: 67%;" />

#### UDP：

udp有16位的长度描述数据包的大小，理论上的最大值=2^16=64k

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20150408190203005" alt="img" style="zoom:67%;" />

### 2.数据包的长度问题？MTU?

每个网络的MTU(最大可传输单元)值是不同的，这个值其实是由底层硬件决定的。**1500字节这个值是一个经验值**。还需要注意一点就是，本地MTU和网络MTU：

- 本地MTU>网络MTU：网络会进行拆包，这样一来数据包数量增多，二来也增加了拆包组包的时间
- 本地MTU<网络MTU：可以直接传输，却没有完全利用网络的传输能力

![img](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20200411091323238.png)

根据ip协议格式可知，ip有16位的长度来描述数据包大小=65535字节。所以IP数据包可以大于MTU的长度，只是ip协议在数据包大于MTU时会进行分片而已！！！这样使得较小的报文能在数据链路层传输。

#### MTU对UDP的影响：

因为udp有16bit长度描述udp包的大小，所以udp最大包是65535字节，但是一般情况下，udp的包都是不超过1472(1500-20ip首部-8udp首部)，这样才不会在网络层被分包。

如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到1500，还是8000。如果某个IP分片丢失了，recvfrom(9000)，又返回什么呢？

根据UDP通信的有界性，在buf足够大的情况下，接收到的一定是一个完整的数据包，**UDP数据在下层的分片和组片问题由IP层来处理，提交到UDP传输层一定是一个完整的UDP包**，那么recvfrom(9000)将返回8000。如果某个IP分片丢失，udp里有个CRC检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以UDP是不可靠的传输协议，那么recvfrom(9000)将阻塞。

#### MTU对TCP的影响：

很重要的一点，tcp的结构中并没有对数据长度的定义，所以理论上tcp的数据包是没有限制的。但是也不是无限大的。

TCP单个数据报的最大消息长度，称为 MSS。TCP 在建立连接的过程中，双方会进行 MSS 协商 。双方在发送 SYN 的时候会在 TCP 的头部写入字节能支持的 MSS值然后双方得知对方的 MSS 值之后，选择**较小**的作为最终MSS。MMS 的值就在 TCP 首部的 40 字节变长选项中（kind=2）

### **4.网络丢包常见原因：**

- 传输质量不好，或者拥塞，经过节点设备收到大量转发的包，而超出转发端口的最大速率，导致丢弃一部分包(**除非大面积用户网有问题**)
- 环境中存在节点ip或者mac冲突，导致一部分包发给错误的mac，导致正常路径没有收到包
- 和第二点相同，有的设备有多个网卡，配置有不同的ip地址，当接在同一个交换机下的时候，会出现响应目的ip是另一个网卡ip的arp请求，导致ping的request发给另一个mac地址，而这个网卡不是自己所属ip，可能不回ping的reply消息，造成源设备打印time out
- 自己或经过的节点设备路由配置错误，导致发给另一个节点ip，而这个节点没有转发功能，ping的request被终止在设备利，而导致丢包

### 5.输入网址到页面显示，期间发生了什么？

- 访问DNS服务器，获取域名对应的IP地址
- 获取完ip后，进入操作系统的协议栈处理
  - tcp
  - ip
  - mac
- 操作系统通过网卡驱动，将数字信号转成电信号在网线上传输
- 经过路由器转发
- 请求到达服务器后解析http报文的内容，然后再返回给客户端
- 客户端拿到数据后，浏览器就开始解析渲染了

![image-20220819114416228](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220819114416228.png)

### 6.linux如何接受网络包？如何发包？

最简单的方式是依赖中断，也就是收到一个包就触发一次中断告诉os，这样的问题在于当包数量非常多时，频繁的触发中断会导致cpu一直没完没了的处理中断，导致其他任务无法继续前进，从而影响整体效率。

linux2.6版本引入了`NAPI机制`。采用**中断和轮询**的方式来接受包。

收包过程：

- 网络包到达，DMA将包存入ring buffer中，接着网卡向cpu发起硬件中断
- 硬件中断处理函数会唤醒`ksoftirqd`内核线程，轮询处理数据
  - 从ring buffer中读取一帧数据，用sk_buff表示，进入网络协议栈开始逐层处理
  - 网络接口层，验证报文合法性，然后丢给网络层
  - 网络层则取出ip包，判断是转发是交给上层处理还是转发出去。确认是发给本机的，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。
  - 传输层取出TCP或UDP头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。
  - 应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。

发包过程：

- 调用socket发送数据的接口，进入内核态，内核申请一个内核态的sk_buff内存，将用户数据拷贝到sk_buff内存，并将其加入发送缓冲区
- 网络协议栈从soket发送缓冲区取出sk_buff，按照tcp/ip协议从上到下逐层处理
- 如果使用的是 TCP 传输协议发送数据，那么**先拷贝一个新的 sk_buff 副本** ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。**而 TCP 协议是支持丢失重传的**，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，**等收到 ACK 再真正删除**。



<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830143955044.png" alt="image-20220830143955044" style="zoom: 33%;" />



### 7.发送网络数据时，涉及几次内存拷贝？

为了避免层级之间发生拷贝，只用sk_buff一个结构体来描述所有的网络包，通过里面的data指针来调整。



<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830145628056.png" alt="image-20220830145628056" style="zoom: 67%;" />

1. 调用socket系统调用时，内核申请sk_buff，将用户数据拷贝到sk_buff中
2. tcp传输时，每一个sk_buff都会被拷贝一份，用来实现tcp的可靠传输，当收到这个数据包的ack时，才会释放掉sk_buff
3. 当ip层发现sk_buf大于mtu时，会申请额外的sk_buff，将原来的sk_buff拷贝为多个小的sk_buff

### 8.TCP和DUP可以使用同一个端口吗？

可以的，因为tcp、udp是两个不同的处理模块，ip协议中有一字段标志是使用tcp还是udp协议。

## IP篇

### 1.ip协议的作用？格式?

应该说是网络层的作用：实现主机与主机之间的通信，也叫点对点通信。

~~ip是负责没有直连的两个设备的通信~~

~~mac地址是实现直连的两个设备之间的通信~~

![img](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/916092-20170707142324331-1201756642.png)

**ip协议的特点:**

- 无连接：通信双方都不会维护对方的任何信息
- 不可靠：ip协议不保证数据能够准确达到接收端，尽力交付
- 无状态：指的是通信双方不同步传输数据的状态信息，IP数据报的发送、传输、接收都是互相独立的，没有上下文关系，因此接收端可能收到重复、乱序的报文段。

### **2.什么是IP地址、DNS、网关**

**IP地址：**

​	IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此屏蔽物理地址的差异。

​	IP地址分割成**网络号**+**主机号**，网络号就是说在哪个网络环境里面，而主机号就是说这个网络里面的第多少位主机。例如IP地址为192.168.1.1，子网掩码为255.255.255.0，这就说明这个电脑在网络为192.168.1内，主机号是1（主机号不能全是0或全是1），网络192.168.1内最多有254台主机(2^8 -2)

**子网掩码：**

​	主要是为了同IP&一下，计算得到网络号。

**网关：**

​	网关实质是一个网络通向其他网络的IP地址，假设

​	A网络192.168.1.1~192.168.1.254，子网掩码255.255.255.0

​	B网络192.168.2.1~192.168.2.254，子网掩码255.255.255.0

​	在没有路由器的情况下，两个网络之间是不能进行通信的

### **3.ping命令过程**

ping命令使用的是icmp.

![image-20220830161825521](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830161825521.png)

## TCP篇

### tcp基础认识

#### 1. tcp协议格式：

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20150408112844806" alt="img" style="zoom: 67%;" />

标志的意义：

- `SYN`：建立连接时才有
- `FIN`：断开链接
- `ACK`：响应
- `PSH`：表示有data传输
- `RST`：表示连接重置，如果继续使用这条连接，操作系统会发**SIGPIPE**信号

#### 2. 什么是tcp?

tcp是**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议。

**TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因**，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需将SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。

- 面向连接：一定是「**一对一**」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- 可靠的：无论网络中发生了什么问题，tcp都能确保一个报文能够达到对端
- 字节流：
  - 用户数据被切分成多个分组，如果接收方不知道消息的边界，是无法读出一个有效的用户数据的
  - tcp报文是有序的，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

#### 3. 什么是tcp连接？

**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。**所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。

- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

#### 4. 如何确定唯一一个tcp连接呢？

tcp四元组：源地址+源端口号+目的地址+目标端口号

#### 5. 有一个ip的服务器监听了一个端口，它的tcp最大连接数是多少？

tcp连接四元组可知，源地址和端口固定了，所以剩下的目的地址和目标端口号决定了连接上限：

```
//ipv4
连接数量 = 客户端ip*客户端的端口号=2^32 * 2^16 = 2^48
```

当然只是理论上的连接，实际上远远达不到：

- 文件描述符限制：每个tcp连接都是一个文件，如果文件描述符占满了，会发生too many open files。
  - 系统级：当前系统可打开的最大数量，/proc/sys/fs/file-max
  - 用户级：指定用户可打开的最大数量，/etc/security/limits.conf
  - 进程级：单个进程可打开的文件数量，/proc/sys/fs/nr_open
- 内存限制

#### 6. tcp和udp的区别？

1. **连接**：tcp需要建立连接，udp即可传输数据，无需连接
2. **服务对象：**tcp是一对一的，udp可以1:1、1:n、n:n模式
3. **可靠性**：tcp可靠，udp不可靠
4. **拥塞、流量控制：**udp没有，即使网络很拥堵也不会影响udp的发生速度
5. **传输方式**：tcp流式传输，没有边界，但是保证顺序和可靠。**udp是一个包一个包的发**，有边界，但是可能丢包和乱序。
6. **分片不同**：
   1. TCP 的数据大小如果大于 **MSS** 大小，则会在**传输层进行分片**，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
   2. UDP 的数据大小如果大于 **MTU** 大小，则会在 **IP 层进行分片**，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

### tcp连接建立

#### 1. 建立连接的过程：

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/三次握手.jpg" style="zoom: 67%;" />

#### 2. 如何查看网络状况：

```
netstat -ntlp
```

#### 3. 为什么是三次握手？不是两次或者四次？

通过前面的定义，我们知道了什么是tcp连接，所以这个问题重点在于：<u>*为什么三次握手可以初始化socket、序列号和窗口大小并建立tcp连接。*</u>

##### 原因一：避免历史连接

服务端收到历史的SYN报文，回复了ACK，此时客户端发现ACK序号并不对，就会拒绝建立这个连接。

##### 原因二：同步双方初始序列号

**序列号**是可靠传输的一个关键因素，可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）

##### 原因三：避免资源浪费

假设只有两次握手，那么服务器每收到一个SYN都得分配资源建立连接。场景：

客户端发送SYN报文后网络阻塞导致延后了，超时后又重发SYN。那么这两个SYN报文都会导致连接建立。

A：你听得到吗？

B：我听得到，你呢？

A：你听得到吗？（此时B肯定以为A没收到，然后又重新问一遍...）

#### 4. 为什么每次建立tcp连接时，seq都要求不一样？

为了避免接收到历史报文。**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**。不要以为序列号的上限值是 4GB，就以为很大，很难发生回绕。在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps 参数是默认开启的，开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，**一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）**。

#### 5. 为什么ip层提供了分片功能，tcp还需要MSS？

理论上ip报文一次最大是64kb数据，假设tcp就传输了64kb，在ip层任然是会对数据进行分片的，假设ip丢了一个分片，那么整个ip报文都会被丢弃。此时接收方发现tcp报文不完整，就不会发送ack，导致tcp发送方超时重传整个数据。因此**ip层进行分片传输是非常没有效率的**。

#### 6. 三次握手中报文丢失了会发生什么?

*<u>ack报文是不会单独重传的！！！</u>*

##### 第一次丢失：

客户端发送SYN报文后，没有收到SYN-ACK就会触发超时重传，**重传的SYN序列号是一样的**。重传次数可以控制

```shell
cat /proc/sys/net/ipv4/tcp_syn_retrites
```

但是时间间隔一般都是写死在内核中的，而且每次超时时间都是上一次的**两倍**。

超过重传上限次数后，断开连接，表示为connet报错返回。

##### **第二次丢失：**

服务端发送SYN-ACK报文丢失了，客户端会重发SYN报文，服务端会重发SYN-ACK报文。

##### 第三次丢失：

服务端没收到ack就会重发SYN-ACK报文。**需要重点关注一下客户端问题**：

客户端发送完ack后就进入了established状态，只有当Client向server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220901120951066.png" alt="image-20220901120951066" style="zoom: 33%;" />

#### 7. 什么是是syn攻击？如何避免？

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220901122233553.png" alt="image-20220901122233553" style="zoom:50%;" />

linux内处理tcp连接的流程：

- 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出连接对象。

syn攻击就是把syn队列给你塞满导致无法响应客户端，具体操作就是短时间内使用大量不同的ip发送syn报文，使得被攻击者有大量的**SYN_REVC **状态连接，然后收不到客户端的ack就触发重传，发送多次syn-ack报文。

**解决方案**：

- 调大 netdev_max_backlog；
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies；
- 减少 SYN+ACK 重传次数：缩短SYN_REVC状态

### tcp连接断开

#### 1. 断开的过程

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/四次挥手.jpg" style="zoom: 67%;" />

#### 2. 为什么是四次挥手，可以变成三次吗？

有些情况下，四次挥手是可以变成三次挥手的。

四次挥手的表面现象是因为服务端的ack报文和fin报文是分开发送的，深层原因在于：客户端发送fin报文后只表示客户端没有数据要发送了，但是服务端可能还需要发送数据，所以不能立刻发送FIN报文，而是将FIN报文的控制器交给应用程序。

- 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数。
- 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数。

当被动关闭方在 TCP 挥手过程中，如果**「没有数据要发送」**，同时**「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」**，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

#### 3. 粗暴关闭和优雅关闭？

##### 粗暴关闭close：

调用close表示**同时关闭**了自己的**接收**和**发送**功能，如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，**直到引用计数变为 0，才会发出 FIN 报文**。

**如果客户端调用close关闭**，此时服务端发来了数据，客户端内核会回复一个RST报文给服务端，此时客户端就直接释放链接 了。而服务端同样也是释放连接，当服务端再次发起读写操作时，就能感知到连接被释放了：

- 服务端-读操作，返回RST的报错，也就是Connection reset by peer（表示对端关闭了）
- 服务端-写操作，内核直接给应用发一个 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。

##### 优雅关闭shoutdown：

shoutdown函数只关闭发送功能，还保留接收功能。如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手。

#### 4. 四次挥手中丢失了报文会发生什么？

```shell
//FIN包重传次数，超过以后就直接进入closed状态了
cat /proc/sys/net/ipv4/tcp_orphan_retries
```

#### 5. 谁先关闭tcp连接？

客户端和服务端都能够主动关闭连接，只是主动关闭的一方就会有一个TIME_WAIT的状态。被动关闭的一方进入CLOSE_WAIT。

**客户端主动关闭**：

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220819162752840.png" alt="image-20220819162752840" style="zoom:50%;" />

客户端主动关闭连接，发送FIN包，服务端收到后，先发送ACK给客户端表示已经收到，然后客户端---->服务端这条连接就可以关闭了。此时服务器不会立刻关闭连接，还需要处理剩下的数据。

此时客户端能接受但是不能发送，处于FIN_WAIT2状态。服务器处于CLOSE_WAIT。服务端发送完成后再向客户端发送FIN包，客户端收到后再确认关闭，此时TCP就完全断开了。

**服务端主动关闭**：

如果是服务端主动发起关闭，此时客户端再发送数据，根据tcp协议规定，就会认为它是一个异常终止连接，客户端将收到服务端发送的**RST报文**。如果客户端再次发送数据，那么就会操作系统将会发送一个`SIGPIPE`信号给客户端进程，告诉客户端该方向的连接已经关闭了，不要再写了。**SIGPIPE信号的默认处理是直接终止该信号的进程**。所以不想客户端挂掉就使用signal注册一下SIGPIPE的处理函数把。

#### 6.为什么需要TIME_WAIT状态？

linux下面msl默认时30s，所以time_wait是60s写死的。一般重传时间RTO

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收
  - tcp是基于ip协议的，ip协议中有一个ttl字段，最大路由数，每经过一个路由器就减一，当此值为0时数据报被丢弃，同时发送ICMP报文通知源主机。msl就是ttl消耗为0的时间，确保报文已经自然消亡。
- 保证「被动关闭连接」的一方，能够正确的关闭
  - 如果没有time_wait状态，主动断开一方收到FIN包，发出ACK包后进入close状态，如果ack丢失了，被动断开的一方重传FIN包则会收到一个RST报文，导致被动断开可能出错。
  - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902151534315.png" alt="image-20220902151534315" style="zoom:50%;" />

#### 7.为什么TIME_WAIT等待时间是2MSL？

确保最极端情况下，ACK包、FIN包的存活时间。

主动断开一方发送的最后一个ACK响应包的存活时间，以及被动关闭方重传FIN包的存活时间。

#### 8.TIME_WAIT状态过多有什么影响？

- 对于服务端而言，并不影响端口资源，而是导致文件描述符、内存资源、线程资源等被占用。
- 对于客户端而言，如果TIME_WAIT过多导致端口被占用了，就无法建立连接了。(四元组的角度来说)

#### 9.TIME_WAIT状态后收到SYN会发送什么？

看SYN的序列号和时间戳()是非合法。

##### 合法SYN：

重用四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。

##### 非法SYN：

回复一个**第四次挥手的 ACK 报文**，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。

### tcp如何实现可靠传输

首先网络层面的**ip协议是不可靠的**，但是成功发送出去并接受的数据是可靠的把！所以基于此来实现可靠传输。可靠传输的机制：

- 重传机制：序列号与确认应答。
  - `超时重传`（以时间驱动，有定时器）
  - `快速重传`（以数据驱动）
    - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830165207731.png" alt="image-20220830165207731" style="zoom: 33%; float:left" />
    - 重传seq2(必须在收到3个ack才触发，如果seq3也丢了，就不知道)还是seq2之后的报文(重复接受)都存在问题
  - `SACK方法`
    - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830165919300.png" alt="image-20220830165919300" style="zoom:33%; float:left" />
    - tcp携带信息来辅助！！！发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 `SACK` 信息发现只有 `200~299` 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。
    - 要支持sack需要双方都支持，linux2.4以后默认开启

  - ` Duplicate SACK` 使用sack来告诉发送方哪些数据重复了

- 滑动窗口：一问一答的方式效率低，数据包往返时间越长，通信效率越低。所以可以指定一个窗口大小(无需应答)，继续发送数据到最大值。
- 流量控制：考虑接收方的处理能力，限制发送方发数据，否则发送方因为接收方不回消息一直疯狂触发重发机制。
- 拥塞控制：网络是共享环境，可能因为其他主机通信导致网络拥堵，为了避免恶性循环，当网络拥塞时，tcp自我牺牲，降低发送数据量，**避免「发送方」的数据填满整个网络。**
  - `慢启动`：tcp刚刚建立连接就发送大量数据，不给网络添堵吗？所以需要慢慢的增大发送量。**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**
    - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830171353051.png" alt="image-20220830171353051" style="zoom: 50%; float: left;" />

  - `拥塞避免`：为了防止数据越发越多，慢启动有一个门限ssthresh，当超过这个值就会进入拥塞避免算法中。一般来说ssthresh是65535字节。**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**
    - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830171610648.png" alt="image-20220830171610648" style="zoom: 50%; float: left;" />

  - `拥塞发生`：网络拥塞了，会触发重传(收到3个重复ACK)
    - 超时重传时：ssthresh=cwnd/2，cwnd恢复为初始值
    - 快速重传时：cwnd减半，ssthtesh=cwnd

  - `快速恢复`：快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕
    - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220830172123069.png" alt="image-20220830172123069" style="zoom: 50%; float: left;" />

## HTTP篇

### 1.http协议格式？

![image-20220902114946920](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902114946920.png)



### 1.http常见状态码有哪些？

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220831161454907.png" alt="image-20220831161454907" style="zoom:50%;" />

- 302：临时重定向，响应头里面使用字段Location，指明后续要跳转的url，浏览器会自动跳转
- 304：告诉客户端可以继续使用缓存资源，用于缓存控制
- 403：服务器禁止访问，并不是客户端错误
- 404：服务器上找不到资源，并不是客户端错误
- 502：服务器本身没问题，只是访问了其他后端业务出现错误

### 2.http有哪些字段？

- content-length：数据长度，表面本次数据的。因为tcp是无边界的
- connection：客户端要求服务器使用tcp长连接（keep-alive）
- Content-Type：用于服务器响应时，告诉客户端本次数据是什么格式
- Content-Encoding：数据压缩方式，表示服务器返回的数据使用了什么压缩格式

### 3.POST和GET区别？

### 4.http/1.1相比http/1.0提高了什么性能？

- 使用长连接（keep-alive字段）

- Host头处理：

  - 域名系统（DNS）允许多个主机名绑定到同一个IP地址上，假设我们有一个资源URL是http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是`GET /home.html HTTP/1.0`.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。

  - ```http
    GET /home.html HTTP/1.1
    Host: example1.org
    ```

### 5.http/1.1如何优化？

#### 避免发送http请求：

使用缓存，服务器返回资源时，告诉一个过期时间，然后客户端把资源通过	**url-资源**	这种形式存储起来。

#### 在需要发送http请求时，考虑如何减少请求次数：

- 减少重定向请求次数，如果**重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了**。
- 合并请求。把一些资源压缩合并
- 延迟发送请求。当用户真的需要使用时，才向服务器发送请求。(一种方式，或许有的系统想提前获取，增加用户体验)

#### 减少服务器的http响应数据大小：

- 无损压缩
- 有损压缩

## 网络编程篇

### 1.网络编程的接口系列？

客户端：socket()--->bind()----->connect()----->read()/write() ps:使用socket创建的fd读数据

服务端：socket()---->bind()----->listen()--->accept()----->read()/write() ps:使用accept创建的fd读取数据

### 2.为什么socket和accept返回的fd有什么区别？

socket创建的套接字只负责接收客户端的建立连接的请求，而accept建立的连接是用于数据交互的！

当服务端不再需要建立新的连接时，可以把socket()创建的fd给关闭了，不会影响其他已经建立好连接的通信。

举例子：

socket就像是修了一个中间人，负责给两个要交易的人拉到一起，让他们自己去沟通数据。

​									客户a

客户1----------中介	  客户b

​									 客户c

### 3.网络编程的模型？

#### 最基本的socket模型：

这种模型下，服务器只能和一个客户端通信，显然是不合理的。

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902160247900.png" alt="image-20220902160247900" style="zoom: 50%; float: left;" />

在改进模型之前，先看看服务器单机理论上最大能支持多少个客户端：

 TCP 连接是由四元组唯一确认的，这个四元组就是：**本机IP, 本机端口, 对端IP, 对端端口**。服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以**最大 TCP 连接数 = 客户端 IP 数×客户端端口数**。对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是**服务端单机最大 TCP 连接数约为 2 的 48 次方**。

这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：

- **文件描述符**，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，**<u>*单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024*</u>**，不过我们可以通过 ulimit 增大文件描述符的数目；
- **系统内存**，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；

#### 多进程模型：

根据前面的理解，accept()返回的fd(已连接 Socket)才是用来传输数据的，因此可以直接fork一个进程，因为子进程会**复制父进程的文件描述符**，于是就可以直接使用「已连接 Socket 」和客户端通信了。

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902160632214.png" alt="image-20220902160632214" style="zoom:67%;" />

不足在于：

- 如果不对子进程做好处理，会导致僵尸进程
- 子进程数量不可能太多，进程太浪费资源了

#### 多线程模型：

当服务器与客户端 TCP 完成连接后，通过 `pthread_create()` 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。可以使用**线程池**的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902160957377.png" alt="image-20220902160957377" style="zoom: 67%;" />

就算使用了线程池，线程池也不可能无限大把，如果遇到C10K问题，一台机器维护1w个连接，操作系统肯定是扛不住的...

#### I/O多路复用技术？

多线程模型中，当一个连接对应一个线程时，线程一般采用「read -> 业务处理 -> send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 `read` 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。

但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 `read` 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。

要解决这一个问题，最简单的方式就是将 **socket 改成非阻塞**，然后线程不断地**轮询调用 `read`** 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。

上面的问题在于，**线程并不知道当前连接是否有数据可读**，从而需要每次通过 `read` 去试探。那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用。



无需来一个连接就新建一个线程去处理，而是可以实现一个进程管理所有的fd。

先通过socket()创建一个监听socket，丢给io多路复用机制，此时新来一个连接，那么就accept创建一个fd，再丢给io多路复用机制。当accept_fd有读写事件时，io多路复用机制就会通知去消费数据。

相当于在io多路复用机制中，有两块处理，一个是专门处理接收连接的，另外一个就是处理数据交互的。

linux下的io多路复用机制的具体实现有：select、poll、epoll

##### select/poll：

select 实现多路复用的方式是，将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。

所以，对于 select 这种方式，需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长

##### epoll:

- 使用红黑树来跟踪所有待检测的fd，增删改的时间O(logn)
- 事件驱动机制
  - 内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。
  - <img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902162822153.png" alt="image-20220902162822153" style="zoom:50%;float:left" />

###### epoll运行过程：

如果我想要发送数据，

tcp_client::send_data要发送数据，ok，先把数据塞到buff里面，然后往epoll_wait中添加EPOLLOUT事件，同时把write_cb注册进去，然后loop_once下一次就会处理这个事件，然后调用write_cb，把buffer里面的数据拿出来然后通过send发送出去，发送完了以后得把EPOLLOUT事件给删除掉，不然一直会触发。 

###### 触发模型

触发模型针对的是accept返回的fd，也就是后续用于数据交互的fd：

- LT模式：水平触发，有数据就epoll_wait一直返回该fd。
- ET模式：边缘触发，只提示一次，需要与一次性读完所有数据(while读取)

###### 事件：

最常见的网路事件是**EPOLLIN**和**EPOLLOUT**：

- EPOLLIN：socket缓冲区数据可读(收到对端的数据、作为服务端时收到对端的连接)
- EPOLLOUT：socket缓冲区可写

### 4.Reactor模型

Reactor模式主要由Reactor和处理资源池组成：

- Reactor负责监听和分发事件，包括连接事件、读写事件
- 处理资源池负责初始事件逻辑，如read -> 业务逻辑 -> send

#### 单Reactor-单进程/线程：

- Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
- 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，**并创建一个 Handler 对象来处理后续的响应事件**；
- 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；
- Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。



<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220902171002845.png" alt="image-20220902171002845" style="zoom: 50%;" />

缺点在于单进程无法充分利用多核cpu性能，如果handler对象处理业务很耗时，整个进程无法处理其他的连接事件，造成**响应延迟**。

#### 多Reactor-多进程/线程：

MainReactor只负责监听，当连接事件到来时，丢给acceptor去处理。acceptor通过accept返回的fd是丢给SubReactor去监听的，这样subReactor就只需要处理读写事件了。

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/20200628234428690.png" alt="11" style="zoom:50%;" />

### 5.EPOLLOUT事件？

触发EPOLLOUT的场景：

- `客户端连接`：客户端connect上服务端后，accept得到fd，把fd添加到epoll中，因为连接可写，所以触发EPOLLOUT事件。
- `客户端发包`：缓冲区从满到不满，会触发EPOLLOUT事件。
  - 将数据包发完内核缓冲区–>进而由内核再将缓冲区的内容发送出去；这边send只是做了第一部分的工作，如果缓存区满的话send将会得到已发送的数据大小(成功放到缓冲区的)，而不是整个数据包大小。
    这种情况我们可以借助EPOLLOUT事件加以解决：如果send部分成功，则表示缓存区满了，那么把剩下的部分交给epoll，当检测到EPOLLOUT事件后，再将剩余的包发送出去。
- `重新注册`：当连接可用后且缓存不满的情况下，调用epoll_ctl将fd重现添加到epoll，也会触发EPOLLOUT。
  - send或write发包函数会涉及系统调用，存在一定开销，如果能将数据包聚合起来，然后调用writev将多个数据包一并发送，则可以减少系统调用次数，提高效率。这时EPOLLOUT事件就派上用场了：当发包时，可以将先数据包发到数据buffer(用户缓存区)中存放，然后通过重新注册EPOLLOUT事件，从而触发EPOLLOUT事件时，再将数据包一起通过writev发送出去。

### 6.epoll产生过多EPOLLOUT事件导致cpu升高？

1、对于服务端listen socket不需要将EPOLLOUT注册到epoll事件模型中。因为listen socket只是负责接收数据（接收客户端建立连接请求），不会发送数据，所以不需要注册时EPOLLOUT。

2、按需注册EPOLLOUT。当我们调用send接口时，如果返回的-1且errno=EAGAIN时，再注册EPOLLOUT，后续send发送成功后，再将EPOLLOUT从epoll事件模型中移除，这就是按需注册EPOLLOUT。当然我们也可以不用移除，只不过需要判断是否真的有数据需要发送。大名鼎鼎的nginx的做法是：发送完成后会将发送的回调函数设置成一个空函数（这个函数只是定义里面什么都没有做）。nginx为什么不移除呢？因为反复添加、移除EPOLLOUT性能不友好，总是在用户层和内核层来回切换。

### 7.epoll_wait处理所有发送的事情?

### 8.accept处理EMFILE事件？

EMFILE事件表示进程打开的文件描述符达到上限了(linux下一般是1024个)，此时新连接来到时会触发listenfd上的EPOLLIN事件，如果不处理，就会一直触发....

所以一般的解决方案就是采取占位符的方法

<img src="https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/image-20220907110901553.png" alt="image-20220907110901553" style="zoom: 50%;" />



### 9.对端正常close时本端的行为？

### 10.connect的EINPROGRESS？

对于非阻塞式的listenfd，当网络还处于建立连接的过程中时，connect会返回-1，并且errno=EINPROGRESS，对于这种情况，再把这个事件注册到epoll里面去就行了，等完成建立后触发事件再执行用户的命令

```c++
        if (errno == EINPROGRESS)
        {
            //add connection event
            _loop->add_ioev(_sockfd, connection_cb, EPOLLOUT, this);
        }
```
