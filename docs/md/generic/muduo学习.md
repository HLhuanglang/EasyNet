# muduo学习

## tcp编程本质论
看完之后感觉确实通透了很多，解答了一些编写easy_net过程中的问题。先来学习一下这个观点：

网络编程的本质是处理三件半的事情：
- 连接建立：服务器被动接收连接，客户端主动发起连接，当连接建立完成后，双方就是平等的，可以互相收发消息了。
- 连接断开：主动断开(close、shutdown)和被动断开（read返回0）
- 消息到达：文件描述符可读
- 消息发送完毕：这算半个。对于低流量的服务，可不必关心这个事件；另外，这里的“发送完毕”是指数据写入操作系统缓冲区（内核缓冲区），将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。

### 消息到达事件
socket数据到来时，内核从网卡上先读取到数据(放到socket收发缓冲区里面)，网络库事件循环中的可读事件被触发，将数据从内核缓冲区移动到应用缓冲区中，并且网络库会回调一个OnMessage函数表示有消息到达。

由于TCP接收到的可能是半包（即数据不完整），OnMessage要根据协议来判断这个数据包是否完整。

而如果TCP接收到的数据包是完整的，就直接将这个数据包取出来进行处理（read->decode->compute->encode->write）；而如果TCP接收到的数据包不完整，则OnMessage立即返回，这样内核再接收到一些数据时，网络库事件循环中的可读事件又会被触发...直到OnMessage发现数据包已经完整了，才它取出来进行处理（read->decode->compute->encode->write）。

### 消息发送完成事件
假设现在应用层要发送数据，如果内核发送缓冲区足够大，则将要发送的数据全部填入内核缓冲区中，并触发一个发送完成事件，并且网络库会回调一个OnWriteComplete函数表示消息发送完毕；

而如果内核发送缓冲区不足以容纳这么多的数据，则只将其中一部分数据填入内核缓冲区，剩余部分追加到应用层的发送缓冲区中，等内核发送缓冲区将数据发送出去后，会触发一个可写事件，在这个事件中就会将应用层发送缓冲区中的数据填充到内核发送缓冲区中，这时如果内核发送缓冲区不足以容纳应用层发送缓冲区中的全部数据，则只将其中一部分数据填入内核缓冲区...就这样直到应用层发送缓冲区中的数据全部填充到内核缓冲区，网络库事件循环中的发送完成事件会被触发，并回调OnWriteComplete表示消息发送完毕。

这个事件我的理解就是为了解决接收方处理消息过慢，导致发送方内存暴涨的问题。发送方不能一直无脑发送，得做一点流量控制，可以在设置某个标记，在OnWriteComplete回调中修改这个标记表示发送消息完成了，允许发送下一个消息，这样就不会导致发送方自己消息积压，也可以避免丢包。

注意：应用层一定要在应用层发送缓冲区中的数据全部填入内核缓冲区并回调OnWriteComplete表示消息发送完毕后才能继续发送数据，这样做可以避免数据丢包。

## muduo结构

![](https://hl1998-1255562705.cos.ap-shanghai.myqcloud.com/Img/1384555-20181208140242131-1011363286.png)

如果只关注服务端的话，tcp_client可以去掉。

## runInLoop方法

任何一个线程创建并运行了一个EventLoop,该线程就是IO线程。

假设在主线程中调用EventLoopThread创建了一个子线程，子线程内部创建了EventLoop对象并返回对象的指针，此时在主线程就能通过指针调用EventLoop的方法了。

如果主线程调用loop->runInLoop()方法，那么runInLoop方法就会判断到调用者并非loop对象的实际运行线程，因此就会把cb塞到队列中，并且通过eventfd唤醒实际所属的线程来执行cb。