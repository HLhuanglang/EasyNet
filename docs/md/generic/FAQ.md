# 网络编程FAQ

## 1. 为什么accept需要重新返回一个fd？
首先将套接字分个类：

- 监听套接字：int listenfd = socket()
- 连接套接字：int acceptfd = accept()

三次握手listenfd，相当于修建一座桥，而acceptfd是每一个连接，相当于运输的车辆。不可能每次通信都新建一座桥吧？这个设计，我认为是单一职责的一个表现。监听套接字，就负责处理处理连接事件，而连接套接字负责数据传输。因为有不同的运输需要，所以每一个连接都有一个单独的acceptfd。

## 2. 如何处理tcp数据流(粘包问题)？
首先明白一点，tcp的数据是没有边界的，tcp协议中也没有字段限制包的大小(需要注意MSS)。tcp依赖ip协议进行传输，而ip协议提供了分片重组的功能，建立了tcp连接就像搭起了一根水管，所以对端可以一直往水管里面灌水。

问题在于接收端怎么知道哪一片数据是一起的？所以需要在应用层自己做数据分块处理。

## 3. http协议粘包问题？
都知道http协议是基于tcp协议实现的，也就是说http协议是一个应用层协议。这个问题可以这样描述:

"HTTP解析器一次读socket操作获得的数据可能并不直接对应一个完整的HTTP message”，那么应该说这个问题是必然会存在的。

在面向stream的协议基础上实现一个面向message的协议，那么一般来说应用层和底层之间必然存在一个缓冲区和定时器。于是解析的过程就是，从socket中读取一次数据放入缓冲区，并检查目前buffer中内容是否是一个完整的message，如果是，提交给上层并修改队列起始位置，如果不是，不提交数据给上层。

这里存在两个问题，一个是缓冲区必然要设定一个最大上限，另一方面是一般要设置定时器，一段时间内某个连接没有传输足够数据就断开连接并清除buffer，否则很容易被恶意请求占用过多内存而影响整体稳定性。

具体到HTTP协议，HTTP 1.0无keep alive或HTTP 0.9时，一个TCP连接只能传输一个HTTP message，所以一次性读到对端关闭写即可；有keep alive的情况下，一个TCP连接可能顺序传过来多个请求，就需要利用content-length等字段，于是文本协议解析部分，从解析整个报文变为解析HTTP头，并根据HTTP头中相关字段选择后续解析策略了，也就是上面提到的缓冲区和定时器的问题。

至于具体的流解析实现，可以采用有状态实现，即保存一个状态，记录当前扫描到何处，当前状态如何，之后再有新的数据传过来，就不必再把前面扫描过的数据再扫描一遍了；也可以采用无状态的实现，即不记录扫描到何处，不记录当前状态，某次解析后发现不足一个message，就丢弃当前状态，待下次读取数据进队列尾部，再重头开始解析。（对于每个message比较小的场景，无状态版更快，事实上NGINX也是如此实现的）

关于buffer的底层实现，最简单的版本无疑是算法与数据结构入门课上的单数组实现；更详细的优化版往往是元素为数组的链表结构，不过具体的性能表现需要经过非常多的测试之后设定参数与策略。关于HTTP body比较大的情况，一般需要对上层提供流读写的API，避免完全将超大报文体放在内存中。这样也可以传输超大文件，而不是 @寸光寸阴 所说的只能用chunked机制。

参考：https://www.zhihu.com/question/24598268/answer/625136503

## 4. 网络库本身是否需要进行拆包处理？
我目前的理解来说，网络库本身可以无需对数据进行粘包处理。
网络库本身需要维护一个buffer，把接收到的数据放到buffer里面，然后提供给上层协议去使用，上层协议在这个buffer中读取数据，自己做协议拆解。

如果解析数据发现格式错误，可以直接丢弃buffer中的数据(或是断开连接)


## 5. 发送数据大于socket缓冲区时，tcp会发送数据吗?
经过测试，通过write发送数据，对于数据的大小并没限制(write的参数len是size_t类型，受限于这个大小)，一次发送的数据大于soket的发送缓冲区也没有问题，任然能够发送成功，并且返回发送数据的大小。（数据排队(可能分块,但是最后会完整的到达对端)，等着被操作系统发送）

经过测试，read读取的时候，并不是一次性全部读取到数据，受到socket接收缓冲区大小以及用于接收数据的buf大小影响。一般情况下，我们使用epoll都是水平模式，也就是还有数据没读完就下一轮epoll_wait接着读(从上一次读取的位置接着读,前面已经读过的数据就无了.)，直到read返回-1且errno=EAGAIN，此时就表示没数据了。


从不同的角度看，先看发送：
- 对应用层来说，可能就是调用一下send_data就表示说我已经发送成功了。此时数据被缓存在网络库的buffer中
- 对于网络库而言，将buffer中数据，通过write写入socket中就表示发送成功了。此时数据是存在socket的发送缓冲区的。
    - 可能出现说一次socket缓冲区满了，只发送了部分，此时write返回-1，-1 && errno == EAGAIN || errno == EWOULDBLOCK，那么再接着write就行了
- 对于socket而言，什么时候把数据通过网卡发送出去是由操作系统来决定的...

## 6. 服务端超时处理?

假设客户端发送请求后，服务端与之建立了链接，但是由于此时并发比较高，且其他处理比较耗时，导致该请求还没被处理就超时了，此时客户端直接断开链接了，那么服务端是一个什么情况？

