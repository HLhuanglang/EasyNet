#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# makefile.in可以理解成一个编译函数了，根据入参选项执行不同的编译任务
# makefile能够直接使用当前终端下的所有环境变量的值，环境变量的值可以通过toochain.sh修改
# 优先使用自定义的参数,其次才是使用环境变量值，最后使用makefile内置变量值
# []中的表示默认值,没有则无默认值

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#通用配置
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# COMM_MODE=[]					编译模式：LIB、EXE
# COMM_DEFINES=[]				编译宏开关
# COMM_BUILD_TYPE=[DEBUG]		是否带有调试：DEBUG,RELEASE
# COMM_INCDIRS=[]				依赖头文件目录
# COMM_DEP_LIBSDIRS=[]			依赖的第三方库的库目录
# COMM_DEP_LIBS=[]				依赖的第三方库名字
# COMM_DEP_INCDIRS=[]			依赖的第三方库头文件目录


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# LIB模式配置
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# LIB_TARGET_NAME=[]		生成目标名字
# LIB_TYPE=[STATIC]			生成目标类型：SHARED,STATIC,SHARED|STATIC
# LIB_OBJS=[]				依赖目标文件
# LIB_SRCS_DIR				依赖源文件目录
# LIB_OBJS_DIR				依赖目标文件目录
# LIB_OUTDIR=[]				.so|.a的输出目录

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# EXE模式配置
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# EXE_SRCS_DIR
# EXE_TARGET_DIR
# EXE_TARGET


##自选配置
-include easy_net_compile_config.mk

##makeifle变量
include makefilevars.mk

#设定默认值
BUILD_TYPE ?= [DEBUG]
LIB_TYPE ?= [STATIC]

#设定编译工具链
ifdef CROSS_COMPILE
CC 	  = $(CROSS_COMPILE)gcc
CXX   = $(CROSS_COMPILE)g++
CPP   = $(CC) -E    ##预处理
AS 	  = $(CROSS_COMPILE)as
LD	  = $(CROSS_COMPILE)ld
AR	  = $(CROSS_COMPILE)ar
NM	  = $(CROSS_COMPILE)nm
STRIP = $(CROSS_COMPILE)strip
endif

#==============================
#获取编译环境：OS, ARCH
#==============================
TARGET_PLATFORM=$(shell $(CC) -v 2>&1 | grep Target | sed 's/Target: //')
ifneq ($(findstring mingw, $(TARGET_PLATFORM)), )
	OS=Windows
endif
ifneq ($(findstring android, $(TARGET_PLATFORM)), )
	OS=Android
endif
ifneq ($(findstring darwin, $(TARGET_PLATFORM)), )
	OS=Darwin
endif
ifndef OS
	OS=Linux
endif

ifndef ARCH
ARCH=$(shell echo $(TARGET_PLATFORM) | awk -F'-' '{print $$1}')
endif

#==============================
# CXXFLAGS：编译参数
#==============================
ifneq ($(findstring DEBUG, $(COMM_BUILD_TYPE)), )
	DEFAULT_CFLAGS = -ggdb -O0
else
	DEFAULT_CFLAGS = -Wall -Werror -O2
endif

CXXFLAGS ?= $(DEFAULT_CFLAGS)

ifeq ($(findstring -fPIC, $(CXXFLAGS)), )
	CXXFLAGS += -fPIC
endif

ifeq ($(findstring -std, $(CXXFLAGS)), )
	CXXFLAGS += -std=c++11
endif


#==============================
# ARFLAGS
#==============================
ARFLAGS = cr

#==============================
# LDFLAGS：链接参数
#==============================
LDFLAGS += $(addprefix -I, $(COMM_INCDIRS))
LDFLAGS += $(addprefix -D, $(COMM_DEFINES))

ifneq (${COMM_DEP_INCDIRS}, )
	LDFLAGS += $(addprefix -I, $(COMM_DEP_INCDIRS))
endif
ifneq (${COMM_DEP_LIBSDIRS}, )
	LDFLAGS += $(addprefix -L, $(COMM_DEP_LIBSDIRS))
endif
ifneq (${COMM_DEP_LIBS}, )
	LDFLAGS += $(addprefix -l, $(COMM_DEP_LIBS))
endif
ifeq ($(OS), Linux)
	LDFLAGS += -lstdc++ -lpthread -lm -ldl
endif

#==============================
# 编译动作
#==============================
.PHONY:build
build: ${COMM_MODE}

####编译LIB
.PHONY: LIB
LIB:${LIB_OBJS}
ifneq ($(findstring SHARED, $(LIB_TYPE)), )
	$(CXX) -shared $^ -o $(LIB_OUTDIR)/lib${LIB_TARGET_NAME}.so $(LDFLAGS)
endif
ifneq ($(findstring STATIC, $(LIB_TYPE)), )
	$(AR) $(ARFLAGS) $(LIB_OUTDIR)/lib${LIB_TARGET_NAME}.a $^
endif

####编译EXE
.PHONY: EXE
EXE:${EXE_TARGET}

####编译规则
${LIB_OBJS_DIR}/%.o:${LIB_SRCS_DIR}/%.cpp
	@mkdir -p $(@D)
	${CXX} ${CXXFLAGS} -c $^ -o $@ ${LDFLAGS}

${EXE_TARGET_DIR}/%:${EXE_SRCS_DIR}/%.cpp
	@mkdir -p $(@D)
	${CXX} -static ${CXXFLAGS}  $^ -o $@ ${LDFLAGS}