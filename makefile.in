#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# makefile.in可以理解成一个编译函数了，根据入参选项执行不同的编译任务
#+++++++++++++++++++++++++++++++++configure++++++++++++++++++++++++++++++++++++++++
# []中的表示默认值,没有则无默认值
#
# MODE=[]					编译模式：LIB、EXE
#LIB模式
#此模式下需要指定LIB_TYPE
#INCDIRS、SRCS

#EXE模式
#编译exe时，m个.cpp、n个.h。m,n>=0


# TARGET_NAME=[]			生成目标名字
# LIB_TYPE=[STATIC]			生成目标类型：SHARED,STATIC,SHARED|STATIC
# BUILD_TYPE=[DEBUG]		是否带有调试：DEBUG,RELEASE
# CROSS_COMPILE=[]			编译工具链
# DEP_LIBSDIRS=[]			依赖的第三方库的库目录
# DEP_LIBS=[]				依赖的第三方库名字
# DEP_INCDIRS=[]			依赖的第三方库头文件目录
# DEFINES=[]				编译宏开关

# OUTDIR=[]					编译输出目录
# INCDIRS=[]				头文件目录
# SRCS=[]					具体的源码
#
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# makefile能够直接使用当前终端下的所有环境变量的值，环境变量的值可以通过toochain.sh修改
# 优先使用上述设置的参数,其次才是使用环境变量值，最后使用makefile内置变量值
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##自选配置
-include easy_net_compile_config.mk

##makeifle变量
include makefilevars.mk

#设定默认值
BUILD_TYPE ?= [DEBUG]
LIB_TYPE ?= [STATIC]

#设定编译工具链
ifdef CROSS_COMPILE
CC 	  = $(CROSS_COMPILE)gcc
CXX   = $(CROSS_COMPILE)g++
CPP   = $(CC) -E    ##预处理
AS 	  = $(CROSS_COMPILE)as
LD	  = $(CROSS_COMPILE)ld
AR	  = $(CROSS_COMPILE)ar
NM	  = $(CROSS_COMPILE)nm
STRIP = $(CROSS_COMPILE)strip
endif

#==============================
#获取编译环境：OS, ARCH
#==============================
TARGET_PLATFORM=$(shell $(CC) -v 2>&1 | grep Target | sed 's/Target: //')
ifneq ($(findstring mingw, $(TARGET_PLATFORM)), )
	OS=Windows
endif
ifneq ($(findstring android, $(TARGET_PLATFORM)), )
	OS=Android
endif
ifneq ($(findstring darwin, $(TARGET_PLATFORM)), )
	OS=Darwin
endif
ifndef OS
	OS=Linux
endif

ifndef ARCH
ARCH=$(shell echo $(TARGET_PLATFORM) | awk -F'-' '{print $$1}')
endif

#==============================
# CXXFLAGS：编译参数
#==============================
ifneq ($(findstring DEBUG, $(BUILD_TYPE)), )
	DEFAULT_CFLAGS = -ggdb -O0
else
	DEFAULT_CFLAGS = -Wall -Werror -O2
endif

CXXFLAGS ?= $(DEFAULT_CFLAGS)

ifeq ($(findstring -fPIC, $(CXXFLAGS)), )
	CXXFLAGS += -fPIC
endif

ifeq ($(findstring -std, $(CXXFLAGS)), )
	CXXFLAGS += -std=c++11
endif


#==============================
# ARFLAGS
#==============================
ARFLAGS = cr

#==============================
# LDFLAGS：链接参数
#==============================
LDFLAGS += $(addprefix -I, $(INCDIRS))
LDFLAGS += $(addprefix -D, $(DEFINES))

ifneq (${DEP_INCDIRS}, )
	LDFLAGS += $(addprefix -I, $(DEP_INCDIRS))
endif
ifneq (${DEP_LIBSDIRS}, )
	LDFLAGS += $(addprefix -L, $(DEP_LIBSDIRS))
endif
ifneq (${DEP_LIBS}, )
	LDFLAGS += $(addprefix -l, $(DEP_LIBS))
endif
ifeq ($(OS), Linux)
	LDFLAGS += -lstdc++ -lpthread -lm -ldl
endif

#==============================
# 编译动作
#==============================
.PHONY:build
build: ${MODE}

####编译LIB
.PHONY: LIB
LIB:${OBJS}
ifneq ($(findstring SHARED, $(LIB_TYPE)), )
	$(CXX) -shared $^ -o $(OUTDIR)/lib${TARGET_NAME}.so $(LDFLAGS)
endif
ifneq ($(findstring STATIC, $(LIB_TYPE)), )
	$(AR) $(ARFLAGS) $(OUTDIR)/lib${TARGET_NAME}.a $^
endif

####编译EXE
.PHONY: EXE
EXE:${TEST_TARGET}

####编译规则
${OBJS_DIR}/%.o:${SRCS_DIR}/%.cpp
	@mkdir -p $(@D)
	${CXX} ${CXXFLAGS} -c $^ -o $@ ${LDFLAGS}

${TEST_TARGET_DIR}/%:${TEST_SRCS_DIR}/%.cpp
	@mkdir -p $(@D)
	${CXX} -static ${CXXFLAGS}  $^ -o $@ ${LDFLAGS}